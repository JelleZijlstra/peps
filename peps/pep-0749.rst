PEP: 749
Title: Implementing PEP 649
Author: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Requires: 649
Created: 28-May-2024
Python-Version: 3.14
Post-History: <REQUIRED: dates, in dd-mmm-yyyy format, and corresponding links to PEP discussion threads>


Abstract
========

This PEP supplements :pep:`649` by providing various tweaks and additions to its
specification:

* ``from __future__ import annotations`` (:pep:`563`) will continue to exist with
  its current behavior at least until Python 3.13 reaches its end-of-life. Subsequently,
  it will be deprecated and eventually removed.
* A new standard library module, ``annotations``, is added to provide tooling for
  annotations. It will include the ``get_annotations()`` function, an enum for annotation
  formats, a ``ForwardRef`` class, and a helper function for calling ``__annotate__`` functions.
* Annotations in the REPL are lazily evaluated, just like other module-level annotations.
* We specify the behavior of wrapper objects that provide annotations, such as :py:func:`classmethod`
  and code that uses :py:func:`functools.wraps`.
* We recommend against adding a code flag for marking ``__annotate__`` functions
  that can be run in a "fake globals" environment.

Motivation
==========

:pep:`649` provides an excellent framework for creating better semantics for
annotations in Python. However, it leaves some areas underspecified, and some
of its decisions in corner cases are questionable. This PEP proposes several
changes and additions to the specification to address these issues.


The future of ``from __future__ import annotations``
====================================================

:pep:`563` previously introduced the future import ``from __future__ import annotations``,
which changes all annotations to strings. :pep:`649` proposes an alternative approach
that does not require this future import, and states:

    If this PEP is accepted, PEP 563 will be deprecated and eventually removed. 

However, the PEP does not provide a detailed plan for this deprecation.

Specification
-------------

We suggest the following deprecation plan:

- In Python 3.14, ``from __future__ import annotations`` will continue to work as it
  did before, converting annotations into strings.
- After the last release that did not support :pep:`649` semantics (expected to be 3.13)
  reaches its end-of-life, ``from __future__ import annotations`` is deprecated. Compiling
  any code that uses the future import will emit a :py:exc:`DeprecationWarning`.
- After at least two releases, the future import is removed, and annotations are always
  evaluated as per :pep:`649`. Code that continues to use the future import will raise
  a :py:exc:`SyntaxError`, similar to any other undefined future import.

Rejected alternatives
---------------------

*Immediately make the future import a no-op*: We considered applying :pep:`649` semantics
to all code in Python 3.14, making the future import a no-op. However, this would break
code that works in 3.13 under the following set of conditions:

* ``__future__ import annotations`` is active
* There are annotations that rely on forward references
* A class or function decorator is used that eagerly evalutes annotations (e.g.,
  ``@dataclasses.dataclass`` or an equivalent in a third-party module)

This is expected to be a common pattern, so we cannot afford to break such code during
the upgrade from 3.13 to 3.14.

Such code would still break when the future import is eventually removed. However, this
is many years in the future, giving affected decorators plenty of time to update their code.

*Immediately deprecate the future import*: Instead of waiting until Python 3.13 reaches
its end-of-life, we could immediately start emitting warnings when the future import is
used. However, many libraries are already using ``from __future__ import annotations`` as
an elegant way to enable unrestricted forward references in their annotations. If we deprecate
the future import immediately, it would be impossible for these libraries to use unrestricted
forward references on all supported Python versions while avoiding deprecation warnings:
unlike other features deprecated from the standard library, a ``__future__`` import must
be the first statement in a given module, meaning it would be impossible to only
conditionally import ``__future__.annotations`` on Python 3.13 and lower. (The necessary
``sys.version_info`` check would count as a statement preceding the ``__future__`` import.)

*Keep the future import around forever*: We could also decide to keep the future import
indefinitely. However, this would permanently bifurcate the behavior of the Python
language. This is undesirable; the language should have only a single set of semantics,
not two permanently different modes.

New ``annotations`` module
==========================

:pep:`649` proposes to add tooling related to annotations to the :py:mod:`inspect`
module. However, that module is rather large, has direct or indirect dependencies
on at least 35 other standard library modules, and is so slow to import that other
standard library modules are often discouraged from importing it. Furthermore, we
anticipate adding more tools in addition to the :py:func:`inspect.get_annotations`
function and the ``VALUE``, ``FORWARDREF``, and ``SOURCE`` formats.

A new standard library module provides a logical home for this functionality and
also enables us to add more tooling that is useful for consumers of annotations.

Rationale
---------

``annotations.ForwardRef`` replaces :py:class:`typing.ForwardRef`. The latter is a problematic
class: it is public and documented, but the documentation lists no attributes or methods
for it. Nonetheless, third-party libraries make use of some of its undocumented
attributes. For instance, `pydantic <https://github.com/pydantic/pydantic/blob/00ff77ed37589d924d3c10e0d5a48a7ef679a0d7/pydantic/v1/typing.py#L66>`__
and `typeguard <https://github.com/agronholm/typeguard/blob/016f8139f5a0a63147d68df9558cc5584cd2c49a/src/typeguard/_utils.py#L44>`__
use the ``_evaluate`` method; `beartype <https://github.com/beartype/beartype/blob/0b4453f83c7ed4be054d8733aab8075e1478e166/beartype/_util/hint/pep/proposal/pep484585/utilpep484585ref.py#L210>`__
and `pyanalyze <https://github.com/quora/pyanalyze/blob/9e401724f9d035cf138b72612834b6d5a00eb8e8/pyanalyze/annotations.py#L509>`__
use the ``__forward_arg__`` attribute.

:pep:`649` indicates that :py:class:`!typing.ForwardRef` should be used to implement the
``FORWARDREF`` format in :py:func:`inspect.get_annotations`. However, the existing implementation
of :py:class:`!typing.ForwardRef` is intertwined with the rest of the :py:mod:`!typing` module,
and it would not make sense to add :py:mod:`!typing`-specific behavior to the generic ``get_annotations()``
function.

We replace the existing but poorly specified :py:class:`!typing.ForwardRef` with a new class,
``annotations.ForwardRef``. It is designed to be mostly compatible with existing uses
of the :py:class:`!typing.ForwardRef` class, but without the behaviors specific to the
:py:mod:`!typing` module. For compatibility with existing users, we keep the private
``_evaluate`` method, but mark it as deprecated. It delegates to a new public function in
the :py:mod:`!typing` module, ``typing.evaluate_forward_ref``, that is designed to
evaluate forward references in a way that is specific to type hints.

We add a function ``annotations.call_annotate_function`` as a helper for calling
``__annotate__`` functions. This is a useful building block when implementing functionality
that needs to partially evaluate annotations while a class is being constructed.
For example, the implementation of :py:class:`typing.NamedTuple` needs to retrieve
the annotations from a class namespace dictionary before the namedtuple class itself
can be constructed, because the annotations determine what fields exist on the namedtuple.

Specification
-------------

A new module, ``annotations``, is added to the standard library. Its aim is to
provide tooling for introspecting and wrapping annotations.

The exact contents of the module are not yet specified. We will add support for
:pep:`649` semantics to standard library functionality that uses annotations, such
as :py:mod:`dataclasses` and :py:class:`typing.TypedDict`, and use the experience
to inform the design of the new module.

The module will contain the following functionality:

* ``get_annotations()``: A function that returns the annotations of a function,
  module, or class. This will replace :py:func:`inspect.get_annotations`. The latter
  will delegate to the new function. It may eventually be deprecated, but to
  minimize disruption, we do not propose an immediate deprecation.
* ``Format``: an enum that contains the possible formats of annotations. This will
  replace the ``VALUE``, ``FORWARDREF``, and ``SOURCE`` formats in :pep:`649`.
  :pep:`649` proposed to make these values global members of the :py:mod:`inspect`
  module; we prefer to place them within an enum.
* ``ForwardRef``: a class representing a forward reference; it may be returned by
  ``get_annotations()`` when the format is ``FORWARDREF``. The existing class
  :py:class:`typing.ForwardRef` will become an alias of this class. Its members include:
  * ``__forward_arg__``: the string argument of the forward reference
  * ``evaluate(globals=None, locals=None, type_params=None, owner=None)``: a method that attempts to evaluate
    the forward reference. The ``ForwardRef`` object may hold a reference to the
    globals and other namespaces of the object that it originated from. If so, these
    namespaces may be used to evaluate the forward reference. The *owner* argument
    may be the object that holds the original annotation, such as the class or module
    object; it is used to extract the globals and locals namespaces if these are not
    provided.
  * ``_evaluate()``, with the same interface as the existing ``ForwardRef._evaluate``
    method. It will be undocumented and immediately deprecated. It is provided for
    compatibility with existing users of ``typing.ForwardRef``.
* ``call_annotate_function(func: Callable, format: Format)``: a helper for calling
  an ``__annotate__`` function with a given format. If the function does not support
  this format, ``call_annotate_function()`` will set up a "fake globals" environment,
  as described in :pep:`649`, and use that environment to return the desired annotations
  format.

A new function is also added to the :py:mod:`!typing` module, ``typing.evaluate_forward_ref``.
This function is a wrapper around the ``ForwardRef.evaluate`` method, but it performs
additional work that is specific to type hints. For example, it recurses into complex
types and evaluates additional forward references within these types.

Open issues
-----------

What should this module be called? Some ideas:

- ``annotations``: The most obvious name, but it may cause confusion with the existing
  ``from __future__ import annotations``. There is a PyPI package :pypi:`annotations`,
  but it had only a single release in 2015 and looks abandoned.
- ``annotools``: Analogous to :py:mod:`itertools` and :py:mod:`functools`, but "anno" is a less
  obvious abbreviation than "iter" or "func". As of this writing, there
  is no PyPI package with this name.
- ``annotationtools``: A more explicit version. There is a PyPI package
  :pypi:`annotationtools`, which had a release in 2023.

Rejected alternatives
---------------------

*Add the functionality to the :py:mod:`inspect` module*: As described above, the
:py:mod:`!inspect` module is already quite large, and its import time is prohibitive
for some use cases.

*Add the functionality to the :py:mod:`typing` module*: While annotations are mostly
used for typing, they may also be used for other purposes. We prefer to keep a clean
separation between functionality for introspecting annotations and functionality that
is exclusively meant for type hints.

*Add the functionality to the :py:mod:`types` module*: The :py:mod:`types` module is
meant for functionality related to *types*, and annotations can exist on functions
and modules, not only on types.

*Develop this functionality in a third-party package*: The functionality in this new
module will be pure Python code, and it is possible to implement a third-party package
that provides the same functionality by interacting directly with ``__annotate__``
functions generated by the interpreter. However, the functionality of the proposed new
module will certainly be useful in the standard library itself (e.g., for implementing
dataclasses), so it makes sense to include it in the standard library.

*Add this functionality to a private module*: It would be possible to initially develop
the module in a private standard library module (e.g., ``_annotations``), and publicize
it only after we have gained more experience with the API. However, we already know
that we will need parts of this module for the standard library itself (e.g., for
implementing :py:class:`typing.NamedTuple`). Even if we make it private, the module
will inevitably get used by third-party users. It is preferable to start with a clear,
documented API from the beginning, to enable third-party users to support :pep:`649`
semantics as thoroughly as the standard library.

Behavior of the REPL
====================

:pep:`649` specifies the following behavior of the interactive REPL:

    For the sake of simplicity, in this case we forego delayed evaluation.
    Module-level annotations in the REPL shell will continue to work exactly
    as they do with “stock semantics”, evaluating immediately and setting the
    result directly inside the ``__annotations__`` dict.

There are several problems with this proposed behavior. It makes the REPL the
only context where annotations are still evaluated immediately, which is
confusing for users and complicates the language.

It also makes the implementation of the REPL more complex, as it needs to
ensure that all statements are compiled in "interactive" mode, even if their
output does not need to be displayed. (This matters if there are multiple
statements in a single line evaluated by the REPL.)

Most importantly, this breaks some plausible use cases that inexperienced
users could run into. A user might write the following in a file::

    x: X | None = None
    class X: ...

Under :pep:`649` this would work fine: ``X`` is not yet defined when it is used,
but it is not evaluated. However, if a user were to paste this same code into the
REPL and execute it line by line, it would throw a ``NameError``, because the
name ``X`` is not yet defined.

Specification
-------------

We propose to treat the interactive console like any other module-level code, and
make annotations lazily evaluated. This makes the language more consistent and
avoids subtle behavior changes between modules and the REPL.

Because the REPL is evaluated line by line, we would generate a new ``__annotate__``
function for every evaluated line that contains annotations. Whenever a line
containing annotations is evaluated, the previous ``__annotate__`` function is
lost:

.. code:: pycon

    >>> x: int
    >>> __annotate__(1)
    {'x': <class 'int'>}
    >>> y: str
    >>> __annotate__(1)
    {'y': <class 'str'>}
    >>> z: doesntexist
    >>> __annotate__(1)
    Traceback (most recent call last):
    File "<python-input-5>", line 1, in <module>
        __annotate__(1)
        ~~~~~~~~~~~~^^^
    File "<python-input-4>", line 1, in __annotate__
        z: doesntexist
           ^^^^^^^^^^^
    NameError: name 'doesntexist' is not defined

There will be no ``__annotations__`` key in the global namespace of the REPL.
In module namespaces, this key is created lazily when the ``__annotations__``
descriptor of the module object is accessed, but in the REPL there is no such module
object.

Wrappers that provide ``__annotations__``
=========================================

Several objects in the standard library and elsewhere provide annotations for their
wrapped object. :pep:`649` does not specify how such wrappers should behave.

Specification
-------------

Wrappers that provide annotations should be designed with the following goals
in mind:

* Evaluation of ``__annotations__`` should be deferred for as long as possible,
  consistent with the behavior of built-in functions, classes, and modules.
* Backward compatibility with the behavior prior to the implementation of :pep:`649`
  should be preserved.
* The ``__annotate__`` and ``__annotations__`` attributes should both be supplied
  with semantics consistent to those of the wrapped object.

More specifically:

* :py:func:`functools.update_wrapper` (and therefore :py:func:`functools.wraps`)
  will copy only the ``__annotate__`` attribute
  from the wrapped object to the wrapper. The ``__annotations__`` descriptor on the
  wrapper function will use the copied ``__annotate__``.
* The constructors for :py:func:`classmethod` and :py:func:`staticmethod` currently
  copy the ``__annotations__`` attribute from the wrapped object to the wrapper.
  If this PEP is implemented, they will instead have writable attributes for
  ``__annotate__`` and ``__annotations__``. Reading these attributes will retrieve
  the corresponding attribute from the underlying callable and cache it in the wrapper'sake
  ``__dict__``. Writing to these attributes will directly update the ``__dict__``,
  without affecting the wrapped callable.

Remove code flag for marking ``__annotate__`` functions
=======================================================

:pep:`649` specifies:

    This PEP assumes that
    third-party libraries may implement their own ``__annotate__``
    methods, and those functions would almost certainly work
    incorrectly when run in this "fake globals" environment.
    For that reason, this PEP allocates a flag on code objects,
    one of the unused bits in ``co_flags``, to mean "This code
    object can be run in a 'fake globals' environment."  This
    makes the "fake globals" environment strictly opt-in, and
    it's expected that only ``__annotate__`` methods generated
    by the Python compiler will set it.

We have not found a need for this mechanism during our work to
add :pep:`649` support to the standard library. While it is true
that custom ``__annotate__`` functions may not work well with the
"fake globals" environment, this technique is used only when the
``__annotate__`` function raises :py:exc:`NotImplementedError` to
signal that it does not support the requested format. However,
manually implemented ``__annotate__`` functions are likely to support
all three annotation formats; often, they will consist of a call to
``annotations.call_annotate_function`` plus some transformation of the
result.

In addition, the proposed mechanism couples the implementation with
low-level details of the code object. The code object flags are
CPython-specific and the documentation :py:ref:`explicitly warns <inspect-module-co-flags>`__
against relying on the values.

Specification
-------------

The standard library will use the "fake globals" technique on any
``__annotate__`` function that raises :py:exc:`NotImplementedError`
when the requested format is not supported.

Third-party code that implements ``__annotate__`` functions should either
support all three annotation formats, or be prepared to handle the
"fake globals" environment. This should be mentioned in the data model
documentation for ``__annotate__``.

Backwards Compatibility
=======================

:pep:`649` provides a thorough discussion of the backwards compatibility implications
on existing code that uses either stock or :pep:`563` semantics.

However, there is another set of compatibility problems: new code that is written
assuming :pep:`649` semantics, but uses existing tools that eagerly evaluate annotations.
For example, consider a ``dataclass``-like class decorator ``@annotator`` that retrieves the annotated
fields in the class it decorates, either by accessing ``__annotations__`` directly
or by calling :py:func:`inspect.get_annotations`.

Once :pep:`649` is implemented, code like this will work fine::

    class X:
        y: Y

    class Y: pass

But this will not, unless ``@annotator`` is changed to use the new ``FORWARDREF``
format::

    @annotator
    class X:
        y: Y

    class Y: pass

This is not strictly a backwards compatibility issue, since no previously working code
would break; before :pep:`649`, this code would have raised ``NameError`` at runtime.
In a sense, it is no different from any other new Python feature that needs
to be suppported by third-party libraries. Nevertheless, it is a serious issue for libraries
that perform introspection, and it is important that we make it as easy as possible for
libraries to support the new semantics in a straightforward, user-friendly way.

We will update those parts of the standard library that are affected by this problem,
and we propose to add commonly useful functionality to the new ``annotations`` module,
so third-party tools can use the same set of tools.


Security Implications
=====================

None.


How to Teach This
=================

The semantics of :pep:`649`, as modified by this PEP, should largely be intuitive for
users who add annotations to their code. We eliminate the need for manually adding
quotes around annotations that require forward references, a major source of confusion
for users.

For advanced users who need to introspect annotations, the story becomes more complex.
The documentation of the new ``annotations`` module will serve as a reference for users
who need to interact programmatically with annotations.


Reference Implementation
========================

The in-progress PR `#119891 <https://github.com/python/cpython/pull/119891>`__
implements much of this PEP.

Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

Open issues are tracked `on GitHub <https://github.com/JelleZijlstra/peps/issues/11>`__.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
