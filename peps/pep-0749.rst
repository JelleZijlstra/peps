PEP: 749
Title: Implementing PEP 649
Author: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Typing
Requires: 649
Created: 28-May-2024
Python-Version: 3.14
Post-History: <REQUIRED: dates, in dd-mmm-yyyy format, and corresponding links to PEP discussion threads>


Abstract
========

This PEP supplements :pep:`649` by providing various tweaks and additions to its
specification.


Motivation
==========

:pep:`649` provides an excellent framework for creating better semantics for
annotations in Python. However, it leaves some areas underspecified, and some
of its decisions in corner cases are questionable. This PEP proposes several
changes and additions to the specification to address these issues.


The future of ``from __future__ import annotations``
====================================================

:pep:`563` previously introduced the future import ``from __future__ import annotations``,
which changes all annotations to strings. :pep:`649` proposes an alternative approach
that does not require this future import, and states:

    If this PEP is accepted, PEP 563 will be deprecated and eventually removed. 

However, the PEP does not provide a detailed plan for this deprecation.

Specification
-------------

We suggest the following deprecation plan:

- In Python 3.14, ``from __future__ import annotations`` will continue to work as it
  did before, converting annotations into strings.
- After the last release that did not support :pep:`649` semantics (expected to be 3.13)
  reaches its end-of-life, ``from __future__ import annotations`` is deprecated. Compiling
  any code that uses the future import will emit a :py:exc:`DeprecationWarning`.
- After at least two releases, the future import is removed, and annotations are always
  evaluated as per :pep:`649`. Code that continues to use the future import will raise
  a :py:exc:`SyntaxError`, similar to any other undefined future import.

Rejected alternatives
---------------------

*Immediately make the future import a no-op*: We considered applying :pep:`649` semantics
to all code in Python 3.14, making the future import a no-op. However, this would break
code that works in 3.13 under the following set of conditions:

* ``__future__ import annotations`` is active
* There are annotations that rely on forward references
* A class or function decorator is used that eagerly evalutes annotations (e.g.,
  ``@dataclasses.dataclass`` or an equivalent in a third-party module)

This is expected to be a common pattern, so we cannot afford to break such code during
the upgrade from 3.13 to 3.14.

Such code would still break when the future import is eventually removed. However, this
is many years in the future, giving affected decorators plenty of time to update their code.

*Immediately deprecate the future import*: Instead of waiting until Python 3.13 reaches
its end-of-life, we could immediately start emitting warnings when the future import is
used. However, many libraries are already using ``from __future__ import annotations`` as
an elegant way to enable unrestricted forward references in their annotations. If we deprecate
the future import immediately, it would be impossible for these libraries to use unrestricted
forward references on all supported Python versions while avoiding deprecation warnings:
unlike other features deprecated from the standard library, a ``__future__`` import must
be the first statement in a given module, meaning it would be impossible to only
conditionally import ``__future__.annotations`` on Python 3.13 and lower. (The necessary
``sys.version_info`` check would count as a statement preceding the ``__future__`` import.)

*Keep the future import around forever*: We could also decide to keep the future import
indefinitely. However, this would permanently bifurcate the behavior of the Python
language. This is undesirable; the language should have only a single set of semantics,
not two permanently different modes.

New ``annotations`` module
==========================

:pep:`649` proposes to add tooling related to annotations to the :py:mod:`inspect`
module. However, that module is rather large, has direct or indirect dependencies
on at least 35 other standard library modules, and is so slow to import that other
standard library modules are often discouraged from importing it. Furthermore, we
anticipate adding more tools in addition to the :py:func:`inspect.get_annotations`
function and the ``VALUE``, ``FORWARDREF``, and ``SOURCE`` formats.

A new standard library module provides a logical home for this functionality and
also enables us to add more tooling that is useful for consumers of annotations.

Specification
-------------

A new module, ``annotations``, is added to the standard library. Its aim is to
provide tooling for introspecting and wrapping annotations.

The exact contents of the module are not yet specified. We will add support for
:pep:`649` semantics to standard library functionality that uses annotations, such
as :py:mod:`dataclasses` and :py:class:`typing.TypedDict`, and use the experience
to inform the design of the new module.

The module will contain at least the following functionality:

* ``get_annotations()``: A function that returns the annotations of a function,
  module, or class. This will replace :py:func:`inspect.get_annotations`. The latter
  will delegate to the new function. It may eventually be deprecated, but to
  minimize disruption, we do not propose an immediate deprecation.
* ``Format``: an enum that contains the possible formats of annotations. This will
  replace the ``VALUE``, ``FORWARDREF``, and ``SOURCE`` formats in :pep:`649`.
* ``call_annotate_function(func: Callable, format: Format)``: a helper for calling
  an ``__annotate__`` function with a given format. If the function does not support
  this format, ``call_annotate_function()`` will set up a "fake globals" environment,
  as described in :pep:`649`, and use that environment to return the desired annotations
  format.

Open issues
-----------

What should this module be called? Some ideas:

- ``annotations``: The most obvious name, but it may cause confusion with the existing
  ``from __future__ import annotations``. There is a PyPI package :pypi:`annotations`,
  but it had only a single release in 2015 and looks abandoned.
- ``annotools``: Analogous to ``itertools`` and ``functools``, but "anno" is a less
  obvious abbreviation than "iter" or "func". As of this writing, there
  is no PyPI package with this name.
- ``annotationtools``: A more explicit version. There is a PyPI package
  :pypi:`annotationtools`, that had a release in 2023.

Rejected alternatives
---------------------

*Add the functionality to the :py:mod:`inspect` module*: As described above, the
:py:mod:`inspect` module is already quite large, and its import time is prohibitive
for some use cases.

*Add the functionality to the :py:mod:`typing` module*: While annotations are mostly
used for typing, they may also be used for other purposes. We prefer to keep a clean
separation between functionality for introspecting annotations and functionality that
is exclusively meant for type hints.

*Add the functionality to the :py:mod:`types` module*: The :py:mod:`types` module is
meant for functionality related to *types*, and annotations can exist on functions
and modules, not only on types.

*Develop this functionality in a third-party package*: The functionality in this new
module will be pure Python code, and it is possible to implement a third-party package
that provides the same functionality by interacting directly with ``__annotate__``
functions generated by the interpreter. However, the functionality of the proposed new
module will certainly be useful in the standard library itself (e.g., for implementing
dataclasses), so it makes sense to include it in the standard library.

However, it would be possible to initially develop the module in a private standard library
module (e.g., ``_annotations``), and publicize it only after we have gained more experience
with the API. If so, the parts of the module that definitely need to be public, such as
the ``Format`` enum, could be exported by the ``inspect`` module.

Behavior of the REPL
====================

:pep:`649` specifies the following behavior of the interactive REPL:

    For the sake of simplicity, in this case we forego delayed evaluation.
    Module-level annotations in the REPL shell will continue to work exactly
    as they do with “stock semantics”, evaluating immediately and setting the
    result directly inside the ``__annotations__`` dict.

There are several problems with this proposed behavior. It makes the REPL the
only context where annotations are still evaluated immediately, which is
confusing for users and complicates the language.

It also makes the implementation of the REPL more complex, as it needs to
ensure that all statements are compiled in "interactive" mode, even if their
output does not need to be displayed. (This matters if there are multiple
statements in a single line evaluated by the REPL.)

Most importantly, this breaks some plausible use cases that inexperienced
users could run into. A user might write the following in a file::

    x: X | None = None
    class X: ...

Under :pep:`649` this would work fine: ``X`` is not yet defined when it is used,
but it is not evaluated. However, if a user were to paste this same code into the
REPL and execute it line by line, it would throw a ``NameError``, because the
name ``X`` is not yet defined.

Specification
-------------

We propose to treat the interactive console like any other module-level code, and
make annotations lazily evaluated. This makes the language more consistent and
avoids subtle behavior changes between modules and the REPL.

Because the REPL is evaluated line by line, we would generate a new ``__annotate__``
function for every evaluated line that contains annotations. Whenever a line
containing annotations is evaluated, the previous ``__annotate__`` function is
lost:

.. code:: pycon

    >>> x: int
    >>> __annotate__(1)
    {'x': <class 'int'>}
    >>> y: str
    >>> __annotate__(1)
    {'y': <class 'str'>}
    >>> z: doesntexist
    >>> __annotate__(1)
    Traceback (most recent call last):
    File "<python-input-5>", line 1, in <module>
        __annotate__(1)
        ~~~~~~~~~~~~^^^
    File "<python-input-4>", line 1, in __annotate__
        z: doesntexist
           ^^^^^^^^^^^
    NameError: name 'doesntexist' is not defined


Specification
=============

[Describe the syntax and semantics of any new language feature.]


Backwards Compatibility
=======================

:pep:`649` provides a thorough discussion of the backwards compatibility implications
on existing code that uses either stock or :pep:`563` semantics.

However, there is another set of compatibility problems: new code that is written
assuming :pep:`649` semantics, but uses existing tools that eagerly evaluate annotations.
For example, as of Python 3.13, the ``@dataclass`` decorator retrieves the ``__annotations__``
attribute from the decorated class. The same is generally true for other tools that
rely on runtime introspection of annotations, such as runtime type checkers.

If ``@dataclass`` is not changed, then the following code will work fine when :pep:`649`
is implemented::

    class X:
        y: Y

    class Y: pass

But this will not::

    from dataclasses import dataclass

    @dataclass  # NameError: Y is not defined
    class X:
        y: Y

    class Y: pass

This is not strictly a backwards compatibility issue, since no previously working code
would break. In a sense, it is no different from any other new Python feature that needs
to be suppported by third-party libraries. Nevertheless, it is a serious issue for libraries
that perform introspection, and it is important that we make it as easy as possible for
libraries to support the new semantics in a straightforward, user-friendly way.

We will update those parts of the standard library that are affected by this problem,
and we propose to add commonly useful functionality to the new ``annotations`` module,
so third-party tools can use the same set of tools.


Security Implications
=====================

[How could a malicious user take advantage of this new feature?]


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]


Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

Open issues are tracked `on GitHub <https://github.com/JelleZijlstra/peps/issues/11>`__.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
