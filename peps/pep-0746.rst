PEP: 746
Title: TypedMetadata for type checking of PEP 593 Annotated
Author: Adrian Garcia Badaracco <adrian@adriangb.com>
Sponsor: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Discussions-To: https://discuss.python.org/t/pep-746-typedmetadata-for-type-checking-of-pep-593-annotated/53834
Status: Draft
Type: Standards Track
Topic: Typing
Created: 20-May-2024
Python-Version: 3.13
Post-History: 20-May-2024

Abstract
--------

This PEP proposes a mechanism for integrating metadata in the :pep:`593` ``Annotated`` type
into the type system.

Motivation
----------

:pep:`593` introduced ``Annotated`` as a way to attach runtime metadata to types,
however it does not provide any way to tie the metadata to the type itself.
This can introduce type unsoundness in real world usage, even in examples similar
to those in the PEP.
For example, given a metadata like ``Int64()`` that might instruct how to serialize a field
over the wire, one can write ``Annotated[float, Int64()]`` which is clearly unsound
and could be type checked, but there is currently no mechanism to do so.

Runtime type checking libraries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One of the core desires for :pep:`593` was to allow better integration with runtime
uses of types. It proposed a use case similar to the above ``Int64`` example. However,
it has become clear that one of the most popular use cases for typing in Python is runtime
type checking, as provided by libraries like `pydantic`_ and `msgspec`_.

Pydantic in particular is one of the most popular libraries in the Python ecosystem, and is
in fact downloaded more than type checkers like `mypy`_.

Pydantic makes heavy use ``Annotated`` to attach metadata to types.
For example, consider this example that parses an ``Item`` with a ``price`` field
that allows whitespace, e.g. to be lenient on user input in a web form::

    from typing import Annotated

    from pydantic import BaseModel, parse

    class Item(BaseModel):
        price: Annotated[float, parse(str).transform(str.strip).transform(float)]

    Model.model_validate_json('{"value":"1.0 "}')  # okay!

Staying open to new future use cases
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This proposal is designed to be open to future use cases.
By adding a re-usable generic that is not constrained to specific use cases
we can allow for future use cases that we cannot predict today, just like :pep:`593` did originally.

This is in contrast to proposals addressing more narrow use cases like :pep:`712` which introduced
a new ``converter`` parameter to ``dataclasses.field``.
One can imagine that if in the future we arrive at a de-facto standard for a
converter that uses ``TypedMetadata`` and we can agree upon a way to express allowing an input
type that is different than the field type we could then standardize that via it's own PEP,
but this PEP does not attempt to do so so that we can let these details be worked out more organically.

Rationale
---------

This PEP adds ``TypedMetadata`` to the typing module, which is a generic class
that when unsubstituted is equivalent to the type in ``Annotated``.

For example::
    from typing import TypedMetadata

    class Int64(TypedMetadata[int]):
        ...
  
    Annotated[int, Int64()]  # okay
    Annotated[float, Int64()]  # error because TypedMetadata[float] != TypedMetadata[int]

Specification
-------------

Implementation
~~~~~~~~~~~~~~

The following class is added to the typing module::

    class TypedMetadata[FieldT]:
        ...

Libraries and tools that want to support ``Annotated`` type checking have their
metadata inherit from it::

    from typing import TypedMetadata, Any, Callable, overload

    class Int64(TypedMetadata[int]):
        ...

    class Validate[In: Any, Out](TypedMetadata[Out]):
        @overload
        def parse[NewOut](self, tp: type[NewOut]) -> Validate[In, NewOut]: ...

        @overload
        def parse[NewOut](self: Validate[In, NewOut]) -> Validate[In, NewOut]: ...

        def transform[NewOut](self, func: Callable[[Out], NewOut]) -> Validate[In, NewOut]: ...
    
    parse = Validate().parse  # note that Out is unsubstituted


    # okay
    Annotated[int, Int64()]

    # error
    Annotated[float, Int64()]

    # okay, Validate[Any, str] is explicitly created and str.lower(str) is valid
    Annotated[str, parse(str).transform(str.lower)]

    # error, Validate[Any, str] is explicitly created and str / 1 is invalid
    Annotated[str, parse(str).transform(lambda x: x / 1)]

    # okay, Validate[Any, float] is inferred because type parameter is not substituted
    Annotated[float, parse().transform(lambda x: x / 1)]

    # error, float is inferred and str.lower does not work on float
    Annotated[float, parse().transform(str.lower)]


Reference Implementation
========================

Type checkers should support type checking metadata in ``Annotated`` and they should
follow the behavior that if ``TypedMetadata`` is un-parameterized then it's type parameter
should take the value of the type in ``Annotated``.
All type checkers should support type checking metadata in ``Annotated``.
As of writing only `pyright`_ does.

Rejected ideas
--------------

Introducing a type variable instead of a generic class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introducing a type variable such as ``AnnotatedT = TypeVar('AnnotatedT')`` would require
using the old type variable syntax (pre :pep:`695`) which may eventually be removed from the language

.. _mypy:
   http://www.mypy-lang.org/

.. _pyright:
   https://github.com/microsoft/pyright

.. _pydantic:
   https://github.com/pydantic/pydantic

.. _msgspec:
   https://github.com/jcrist/msgspec

Copyright
---------

This document has been placed in the public domain.
