PEP: 746
Title: TypedMetadata for type checking of PEP 593 Annotated
Author: Adrian Garcia Badaracco <adrian@adriangb.com>
Sponsor: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Discussions-To: https://discuss.python.org/t/pep-746-typedmetadata-for-type-checking-of-pep-593-annotated/53834
Status: Draft
Type: Standards Track
Topic: Typing
Created: 20-May-2024
Python-Version: 3.14
Post-History: 20-May-2024

Abstract
--------

This PEP proposes a mechanism for integrating metadata in the :pep:`593` ``Annotated`` type
into the type system.

Motivation
----------

:pep:`593` introduced ``Annotated`` as a way to attach runtime metadata to types,
however it does not provide any way to tie the metadata to the type itself.
This can introduce type unsoundness in real world usage, even in examples similar
to those in the PEP.

For example, given a metadata like ``Int64()`` that might instruct how to serialize a field
over the wire, one can write ``Annotated[float, Int64()]`` which is clearly unsound
and could be type checked, but there is currently no mechanism to do so.

Specification
-------------

This PEP introduces a new ``__supports_type__`` protocol that both static and
runtime type checkers can use to understand if a metadata object in
``Annotated`` is valid for a given type::

    class Int64:
        def __supports_type__(self, tp: type[int]) -> bool:
            return tp is int

Type checkers will use the function signature to determine if the metadata is valid
while runtime type checkers can call the function at runtime to determine if the metadata is valid.

Libraries and tools that want to support type checking of their metadata should implement
this protocol.

Implementations may be generic, use overloads and return ``Literal[True]`` or ``Literal[False]``
to indicate if the metadata is valid for the given type.

For example, to support a generic ``Gt`` metadata you might do::

    from typing import Protocol

    class SupportsGt[T](Protocol):
        def __gt__(self, __other: T) -> bool:
            ...

    class Gt[T]:
        def __init__(self, value: T) -> None:
            self.value = value

        def __supports_type__(self, t: type[SupportsGt[T]]) -> bool:
            return isinstance(self.value, t)

    Gt(1).__supports_type__(int)  # okay
    Gt(1).__supports_type__(str)  # error
    Gt('a').__supports_type__(str)  # okay
    Gt('a').__supports_type__(int)  # error

Metadata that does not implement the protocol will be considered valid for all types,
thus no breaking changes are introduced even at type-checking time.

Rejected ideas
--------------

Introducing a type variable instead of a generic class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introducing a type variable such as ``AnnotatedT = TypeVar('AnnotatedT')`` would require
using the old type variable syntax (pre :pep:`695`) which may eventually be removed from the language

Introducing a new type to ``typing.py`` that all metadata objects should subclass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This would require adding a type to the already large ``typing.py`` module and would
require a backport via ``typing_extensions`` for older versions of Python.

This is additionally less flexible than the current proposal for complex cases.

Copyright
---------

This document has been placed in the public domain.
