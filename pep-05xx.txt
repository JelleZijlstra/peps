PEP: 5xx
Title: Protocols
Version: $Revision$
Last-Modified: $Date$
Author: Ivan Levkivskyi <levkivskyi@gmail.com>,
        Jukka Lehtosalo <jukka.lehtosalo@iki.fi>,
        ≈Åukasz Langa <lukasz@langa.pl>
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 05-Mar-2017
Python-Version: 3.7


Abstract
========

Type hints introduced in PEP 484 that can be used to specify type metadata
for static type checkers and other third party tools. However, PEP 484
only specifies the semantics of *nominal* subtyping. In this PEP we specify
static and runtime semantics of protocol classes that will provide a support
for *structural* subtyping (static duck typing).


Rationale and Goals
===================

Currently, PEP 484 and ``typing`` module define abstract base classes for
several common Python protocols such as ``Iterable`` and ``Sized``. The problem
with them is that a class has to be explicitly marked to support them, which is
arguably unpythonic and unlike what one would normally do in non statically
typed code. For example, this conforms to the PEP 484::

  from typing import Sized, Iterable, Iterator

  class Bucket(Sized, Iterable[int]):
      ...
      def __len__(self) -> int: ...
      def __iter__(self) -> Iterator[int]: ...

The same problem appears with user defined ABCs, they must be explicitly
subclassed. Moreover, extensive use of ABCs might impose additional runtime
costs. The intention of this PEP is to solve these three problems
by allowing to write the above code without explicit base classes in
the class definition, and ``Bucket`` would still be implicitly considered
a subtype of both ``Sized`` and ``Iterable[int]`` by static type checkers
using structural subtyping::

  from typing import Iterator

  class Bucket:
      ...
      def __len__(self) -> int: ...
      def __iter__(self) -> Iterator[int]: ...

  def collect(items: Iterable[int]) -> int: ...
  collect(Bucket())  # Passes type check

The same functionality will be provided for user defined protocols.


Nominal vs structural subtyping
-------------------------------

The structural subtyping is natural for Python programmers since it matches
the runtime semantics of duck typing: an object that has certain properties
is treated independently of its actual runtime class.
However, ss discussed in PEP 483, both nominal and structural subtyping have
their strengths and weaknesses. Therefore, in this PEP do we not propose
to replace the nominal subtyping described by PEP 484 with structural subtyping
completely. Instead, it is proposed that the protocol classes complement
normal classes, and the choice is left for a user to decide where
to apply a particular solution. See section "Rejected ideas" for additional
motivation.


Non-Goals
---------

Att runtime protocol classes we be simple ABCs. There is no intent to provide
sophisticated runtime instace and class checks against protocol classes.
This would be difficult and error-prone and will contradict the logic
of PEP 484. As well, following PEP 484 and PEP 526 we state that protocols are
**completely optional** and there is no intent to make them required.
No runtime semantics will be imposed for variables or parameters annotated with
a protocol class, the actual checks will be performed by third party type
checkers and other tools.


Existing approaches to structural subtyping
===========================================

Before describing the actual specification, we review existing approaches to
structural subtyping in Python and other languges:

* Zope interfaces::

  from zope.interface import Interface
  from zope.interface import Attribute
  from zope.interface import implements

  class IHost(Interface):
      """A host object"""

      name = Attribute("Name of host")

      def goodmorning(guest):
          """Say good morning to guest"""

  class Host(object):

      implements(IHost)

      name = u''

      def goodmorning(self, guest):
          return "Good morning, %s!" % guest

plus interface contracts/constraints::

  from zope.interface import invariant

  def contacts_invariant(obj):
      if not (obj.email or obj.phone):
          raise Exception("At least one contact info is required")

  class IPerson(Interface):

      name = Attribute("Name")
      email = Attribute("Email Address")
      phone = Attribute("Phone Number")

      invariant(contacts_invariant)

Even more is possible. However, this all requires runtime validation.

* TypeScript::

  interface LabelledValue {
      label: string;
  }

  function printLabel(labelledObj: LabelledValue) {
      console.log(labelledObj.label);
  }

  let myObj = {size: 10, label: "Size 10 Object"};
  printLabel(myObj);

In addition optional members, always errors on reduntant members.

* Go - everything is an interface
* Python abstract base classes

require explicit subclassing or registration.

* Abstract classes in ``collections.abc`` (with ``__subclasshook__``)


Specification
=============

Terminology
-----------

We propose to use the term *protocols* types supoorting structural subtyping.
The reason is that the term iterator protocol,
for example, is widely understood in the community, and coming up with
a new term for this concept in a statically typed context would just create
confusion.

This has the drawback that the term *protocol* becomes overloaded with
two subtly different meanings: the first is the traditional, well-known but
slightly fuzzy concept of protocols such as iterator; the second is the more
explicitly defined concept of protocols in statically typed code.
The distinction is not important most of the time, and in other
cases we propose to just add a qualifier such as *protocol classes*
when refering to the static type concept.

If a class includes a protocol in its MRO, the class is an called an *explicit*
subclass of the protocol. If a class ia a structural subtype of a protocol,
it is said to implement the protocol and to be compatible with a protocol.
If a class is compatible with a protocol but the protocol is not included
in the MRO, the class is an *implicit* subclass of the protocol.

The attributes (variables and methods) of a protocol that are mandatory
for other class in order to be considered a subtype are called
protocol members. Other members defined in a protocol class are called
non-protocol members.


Defining a Protocol
-------------------

There will be a new class ``typing.Protocol``. If this is explicitly included
in the the base class list, the class is a protocol.
Here is a simple example::

  from typing import Protocol

  class SupportsClose(Protocol):
      def close(self) -> None: ...

Now if we define a class ``Resource`` with a close method that has
a suitable signature, it would implicitly be a subtype of ``SupportsClose``,
since we'd use structural subtyping for protocol types::

  class Resource:
      ...

      def close(self) -> None:
          self.file.close()
          self.lock.release()

Protocol types can be used in annotations, of course, and for type checking::

  def close_all(things: Iterable[SupportsClose]) -> None:
      for t in things:
          t.close()

  f = open('foo.txt')
  r = Resource(...)
  close_all([f, r])  # OK!
  close_all([1])  # Error: 'int' has no 'close' method

Note that both the user-defined class ``Resource`` and the ``IO`` type
(the return type of ``open()``) would be considered subtypes of
``SupportsClose`` because they provide a suitable close method.

If using the current ``typing`` module, our only option to implement
the above example would be to use an ABC (or type ``Any``, but that would
compromise type checking). If we'd use an ABC, we'd have to explicitly
register the fact that these types are related, and this generally difficult
to do with library types as the type objects may be hidden deep in
the implementation of the library. Besides, this would be uglier than how
you'd actually write the code in straight, idiomatic dynamically typed Python.
The code with a protocol class matches common Python conventions much better.
It's also automatically extensible and works with additional,
unrelated classes that happen to implement the required interface.


Protocol members
----------------

I propose that most of the regular rules for classes still apply to
protocol classes (modulo a few exceptions that only apply to
protocol classes). I'd like protocols to also be ABCs, so all of these
would be valid within a protocol class::

  # Variant 1
  def __len__(self) -> int: ...

  # Variant 2
  def __len__(self) -> int: pass

  # Variant 3
  @abstractmethod
  def __len__(self) -> int: pass

  # Variant 4
  def __len__(self): pass

  # Variant 5
  def __len__(self) -> int:
      return 0

  # Variant 6
  def __len__(self) -> int:
      raise NotImplementedError

For variants 1, 2 and 3, a type checker should probably always require
an explicit implementation to be defined in a subclass that explicitly
subclasses the protocol (see below for more about this), because
the implementations return ``None`` which is not a valid return type
for the method. For variants 4, 5 and 6, we can use
the provided implementation as a default implementation.
The default implementations won't be used if the subtype relationship
is implicit and only via structural subtyping -- the semantics of inheritance
won't be changed.

I also propose that a ``...`` as the method body in a protocol type makes
the method implicitly abstract. This would only be checked statically,
and there won't be any runtime checking. The idea here is that most methods
in a protocol will be abstract, and having to always use ``@abstractmethod``
is a little verbose and ugly, and has the issue of implicit ``None``
return types confusing things.
This would be the recommended way of defining methods in a protocol that
don't have an implementation, but the other approaches can be used for
legacy code or if people just feel like it. The recommended syntax would
mirror how methods are defined in stub files.

Similar to methods, there will be multiple valid ways of defining data
attributes (or properties). All of these will be valid::

  class Foo(Protocol):
      a = ...  # type: int  # Variant 1
      b = 0  # Variant 2

      # Variant 3
      @property
      def c(self) -> int: ...

      # Variant 4
      @property
      def c(self) -> int:
          return 0

      # Variant 5
      @property
      def d(self) -> int:
          raise NotImplementedError

      # Variant 6
      @abstractproperty
      def e(self) -> int: ...

      # Variant 7
      @abstractproperty
      def f(self) -> int: pass

Also, properties with setters can also be defined. The first three variants
would be the recommended ways of defining attributes or properties,
but similar to 3), the others are possible and may be useful for supporting
legacy code.

When using an ... initializer, ``@abstractproperty`` or ``pass``/``...``
as property body (and when the type does not include ``None``), the data
attribute is considered abstract and must always be explicitly implemented
in a compatible class.

Attributes should not be defined in the body of a method by assignment
via ``self``. This restriction is a little arbitrary, but my idea is that
the protocol class implementation is often not shared by subtypes so
the interface should not depend on the default implementation.
This is more of a style than a technical issue, as a type checker could infer
attributes from assignment statements within methods as well.

When using the ``...`` initializer, the ``... `` initializer might
leak into subclasses at runtime, which is unfortunate::

  class A(Protocol):
      x = ...  # type: int

  class B(A):
      def __init__(self) -> None:
          self.x = 1

  b = B()
  print(b.x)  # 1
  print(B.x)  # Ellipsis

If we'd use a None initializer things wouldn't be any better.
Maybe we can modify the metaclass to recognize ``...`` initializers and
translate them to something else. This needs to be documented, however.
Also, in this proposal there is no way to distinguish between class
and instance data attributes (ClassVar PEP 526).

I'm not sure sure what to do with ``__init__``. I guess a protocol could
provide a default implementation that could be used in explicit subclasses.

Overall, I'm probably the least happy about this part of the proposal.

"Private" variables on self? treat (double?) underscores as private?


Explicitly declaring implementation
-----------------------------------

When a class explicitly inherits from protocol,
typechecker verifies that everything is OK.
in this case normal methods are also inherited.

when a protocol is defined, every method is resolved using
normal MRO procedure. typechecker verifies that everything is OK.
if concrete overrides abstract, then thats it -- it is no more abstract
but not vice versa
set of all remaining abstracts defines the protocol

I propose that protocols can be used as regular base classes.
I can see at least three things that support this decision.
First, a protocol class could define default implementations for some methods
(``typing.Sequence`` would be an example if we decide to turn it
into a protocol). Second, we want a way of statically enforcing that a class
actually implements a protocol correctly (but there are other ways
to achieve this effect -- see below for alternatives).
Third, this makes it possible to turn an existing ABC into a protocol and
just have things (mostly) work.
This would be important for the existing ABCs in typing what we may want
to change into protocols (see point 8 for more about this).
The general philosophy would be that Protocols are mostly like regular ABCs,
but a static type checker will handle them somewhat specially.

Note that subclassing a protocol class would not turn the subclass into
a protocol unless it also has Protocol as an explicit base class.
I assume that we can use metaclass trickery to get this to work correctly.


Merging and extending protocols
-------------------------------

I think that we should support subprotocols. A subprotocol can be defined
by having both one or more protocols as the explicit base classes and also
having typing.Protocol as an immediate base class::

  from typing import Sized, Protocol

  class SizedAndCloseable(Sized, Protocol):
      def close(self) -> None: ...

Now the protocol ``SizedAndCloseable`` is a protocol with two methods,
``__len__`` and ``close``. Alternatively, we could have implemented it
like this, assuming the existence of ``SupportsClose``
from an earlier example::

  from typing import Sized

  class SupportsClose(...): ...  # Like above

  class SizedAndCloseable(Sized, SupportsClose, Protocol):
      pass

The two definitions of ``SizedAndClosable`` would be equivalent.
Subclass relationships between protocols aren't meaningful when
considering subtyping, as we only use structural compatibility
as the criterion, not the MRO.

If we omit ``Protocol`` in the base class list, this would be regular
(non-protocol) class that must implement ``Sized``. If ``Protocol``
is included in the base class list, all the other base classes
must be protocols. A protocol can't extend a regular class.


Generic and recursive Protocols
-------------------------------

``Protocol[T, S, ...]`` as a shorthand for ``Protocol, Generic[T, S, ...]``

Generic protocols are important. For example, ``SupportsAbs``, ``Iterable``
and ``Iterator`` would be generic. We could define them like this,
similar to generic ABCs::

  T = TypeVar('T', covariant=True)

  class Iterable(Protocol[T]):
      def __iter__(self) -> Iterator[T]: ...

Should we support recursive protocols?
Sure, why not. Just use the forward references. They might useful for
representing self-referential
data structures like trees in an abstract fashion, but I don't see them
used commonly in production code.


Interactions of Protocols
=========================

cannot be instantiated.

Subtyping relationships with other types
----------------------------------------

Subtyping: issubtype(A, Proto) is _always_ structural;
issubtype(Proto, Nom) always False.


All(ala Intersection) and Union
-------------------------------

Union merges protocols:
open() -> Union[int, str] conforms to
Union[Proto.open() -> int, Proto.open() -> str],
although it is not a subclass of any of two.


``isinstance()`` and narrowing types
------------------------------------

``isinstance(x, Proto)`` and ``issublclass(C, Proto)``
narrow type if defined with ``@auto_runtime``; ``isinstance(x, Proto[int])``
always fails.

We shouldn't implement any magic ``isinstance()`` machinery, as performing
a runtime compatibility check is generally difficult: we might want to verify
argument counts to methods, names of arguments and even argument types,
depending the kind of protocol we are talking about,
but sometimes we wouldn't care about these, or we'd only care about some
of these things.

My preferred semantics would be to make ``isinstance()`` fail by default
for protocol types. This would be in the spirit of duck typing -- protocols
basically would be used to model duck typing statically, not explicitly
at runtime.

However, it should be possible for protocol types to implement custom
``isinstance`` behavior when this would make sense, similar to how
``Iterable`` and other ABCs in ``collections.abc`` and typing already do it,
but this should be specific to these particular classes.
We need this fallback option anyway for backward compatibility.


``Type[...]`` with protocols
----------------------------

``Type[...]`` accepts only non-abstract (non-protocol?) classes

copy all stuff from my PR


Runtime behavior of protocol classes
====================================

At runtime normal ABCs, cannot be instantiated.


``@auto_runtime`` decorator
---------------------------

(like in ``collections.abc``), typechecker ensures no empty bodies


Changes in typing module
------------------------

I think that at least these classes in typing should be protocols:
(probably all abstract change, concrete stay)

* ``Sized``
* ``Container``
* ``Iterable``
* ``Iterator``
* ``Reversible``
* ``SupportsAbs`` (and other ``Supports*`` classes)

These classes are small and conceptually simple. It's easy to see which of
these protocols a class implements from the presence of a small number
of magic methods, which immediately suggest a protocol.

I'm not sure about other classes such as ``Sequence``, ``Set`` and ``IO``.
I believe that these are sufficiently complex that it makes sense to require
code to be explicit about them, as there would not be any sufficiently obvious
and small set of 'marker' methods that tell that a class implements
this protocol. Also, it's too easy to leave some part of
the protocol/interface unimplemented by accident, and explicitly marking
the subclass relationship allows type checkers to pinpoint the missing
implementations -- or they can be inherited from the ABC,
in case that is has default implementations.
So I'd currently vote against making these classes protocols.


Introspection
-------------

Current typing is already good.

The existing introspection machinery (``dir``, etc.) could be used with
protocols, but typing would not include an implementation of additional
introspection or runtime type checking capabilities for protocols.

As all attributes need to be defined in the class body based on this proposal,
protocol classes would have better support for introspection than
regular classes where attributes can be defined implicitly -- protocol
attributes can't be initialized in ways that are not visible to introspection
(using ``setattr``, assignment via self, etc.). Still, some things like types
of attributes wouldn't be visible at runtime, so this would necessarily be
somewhat limited.


Implementation details
----------------------

We'd need to implement at least the following things:

* Define class ``Protocol`` (this could be simple, and would be similar
to ``Generic``).
* Implement metaclass functionality to detect whether a class is
a protocol or not. Maybe add a class attribute such as ``__protocol__ = True``
if that's the case. Verify that a protocol class only has protocol
base classes in the MRO (except for object).
* Optionally, override ``isinstance``.
* Optionally, translate ``...`` class attribute values to
something else (properties?).


Postponed ideas
===============

Should we support optional attributes?
--------------------------------------

We can come up with examples where it would be handy to be able to say
that a method or data attribute does not need to be present in a class
implementing a protocol, but if it's present, it must conform to a specific
signature or type. One could use a ``hasattr`` check to determine whether
they can use the attribute on a particular instance.

In the interest of simplicity, let's not support optional methods
or attributes. We can always revisit this later if there is an actual need.
The current realistic potential use cases for protocols that I've seen don't
require these. However, other languages have similar features and apparently
they are pretty commonly used. If I remember correctly, at least TypeScript
and Objective-C support a similar concept.


Should these be interoperable with other similar implementations?
-----------------------------------------------------------------

The protocols as described here are basically a small extension to
the existing concept of ABCs. I argue that this is the way they should
be understood, instead of as something that replaces Zope interfaces,
for example.


Make every class a protocol by default
--------------------------------------

Some languages such as Go make structural subtyping the only or the primary
form of subtyping. We could achieve a similar result by making all classes
protocols by default (or even always). I argue that this would be a bad idea
and classes should need to be explicitly marked as protocols,
as shown in my proposal above.

* Protocols don't have some properties of regular classes. In particular,
``isinstance`` is not well-defined for protocols, whereas it's well-defined
(and pretty commonly used) for regular classes.

* Protocol classes should generally not have (many) method implementations,
as they describe an interface, not an implementation.
Most classes have many implementations, making them bad protocol classes.

* Experience suggests that most classes aren't practical as protocols anyway,
mainly because their interfaces are too large, complex or
implementation-oriented (for example, they may include de facto
private attributes and methods without a ``__`` prefix).
Most actually useful protocols in existing Python code seem to be implicit.
The ABCs in typing and ``collections.abc`` are a kind-of exception, but
even they are pretty recent additions to Python and most programmers
do not use them yet.


Use assignments to check explicitly that a class implements a protocol
----------------------------------------------------------------------

I've seen a similar pattern in some Go code that I've reviewed [golang].
Example::

  class A:
      def __len__(self) -> float:
          return ...

  _ = A()  # type: Sized  # Error: A.__len__ doesn't conform to 'Sized'
                          # (Incompatible return type 'float')

I don't much care above the above example, as it moves the check away from
the class definition and it almost requires a comment as otherwise
the code probably wouldn't make any sense to an average reader
-- it looks like dead code. Besides, in the simplest form it requires us
to construct an instance of A which could problematic if this requires
accessing or allocating some resources such as files or sockets.
We could work around the latter by using a cast, for example,
but then the code would be really ugly.


References
==========

.. [mypy]
   http://mypy-lang.org

.. [wiki-structural-subtyping]
   https://en.wikipedia.org/wiki/Structural_type_system

.. [typeshed]
   https://github.com/python/typeshed/

.. [issues]
   https://github.com/python/typing/issues

.. [pep482]
   https://www.python.org/dev/peps/pep-0482/

.. [pep483]
   https://www.python.org/dev/peps/pep-0483/

.. [pep484]
   https://www.python.org/dev/peps/pep-0484/

.. [pep526]
   https://www.python.org/dev/peps/pep-0526/

.. [typescript]
   https://www.typescriptlang.org/docs/handbook/interfaces.html

.. [golang]
   https://golang.org/doc/effective_go.html#interfaces_and_types

.. [zope-interfaces]
   https://zopeinterface.readthedocs.io/en/latest/

.. [abstract-base-classes]
   https://docs.python.org/3/library/abc.html

.. [collections-abc]
   https://docs.python.org/3/library/collections.abc.html


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
